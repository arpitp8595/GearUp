Anjali Kumari(Google): https://leetcode.com/u/Rb_anjali99/

Understand and usage of all patterns: https://www.youtube.com/watch?v=DjYZk8nrXVY&t=85s

System Design Reading Material:
1. https://www.youtube.com/watch?v=Un1CPZ3gIZI


Temp Note: please remove after sometime

### **Problem Analysis (LeetCode 1152 - Analyze User Website Visit Pattern)**

**Problem Statement:**
Given an array of user website visit records (`username[i]`, `timestamp[i]`, `website[i]`), find the **most frequently visited 3-sequence** of websites across all users. A 3-sequence is a list of websites visited in chronological order by the same user.

**Constraints:**
- A user must have visited at least 3 websites.
- If multiple patterns have the same frequency, return the lexicographically smallest one.

---

### **Optimized Java Solution**

```java
import java.util.*;

class Solution {
    public List<String> mostVisitedPattern(String[] username, int[] timestamp, String[] website) {
        // Step 1: Group visits by user (Map<username, List<Visit>>)
        Map<String, List<Visit>> userVisits = new HashMap<>();
        for (int i = 0; i < username.length; i++) {
            userVisits.computeIfAbsent(username[i], k -> new ArrayList<>())
                     .add(new Visit(timestamp[i], website[i]));
        }

        // Step 2: Generate all possible 3-sequences for each user and count frequencies
        Map<List<String>, Integer> sequenceCounts = new HashMap<>();
        for (List<Visit> visits : userVisits.values()) {
            // Skip users with fewer than 3 visits
            if (visits.size() < 3) continue;

            // Sort visits by timestamp
            Collections.sort(visits, (a, b) -> a.timestamp - b.timestamp);

            // Generate all unique 3-sequences for this user
            Set<List<String>> sequences = generateSequences(visits);

            // Update global counts
            for (List<String> seq : sequences) {
                sequenceCounts.put(seq, sequenceCounts.getOrDefault(seq, 0) + 1);
            }
        }

        // Step 3: Find the most frequent sequence (or lex smallest if tied)
        List<String> result = new ArrayList<>();
        int maxCount = 0;
        for (Map.Entry<List<String>, Integer> entry : sequenceCounts.entrySet()) {
            if (entry.getValue() > maxCount) {
                maxCount = entry.getValue();
                result = entry.getKey();
            } else if (entry.getValue() == maxCount &&
                       entry.getKey().toString().compareTo(result.toString()) < 0) {
                result = entry.getKey();
            }
        }

        return result;
    }

    // Helper to generate all unique 3-sequences from a user's sorted visits
    private Set<List<String>> generateSequences(List<Visit> visits) {
        Set<List<String>> sequences = new HashSet<>();
        int n = visits.size();
        for (int i = 0; i < n - 2; i++) {
            for (int j = i + 1; j < n - 1; j++) {
                for (int k = j + 1; k < n; k++) {
                    sequences.add(Arrays.asList(
                        visits.get(i).website,
                        visits.get(j).website,
                        visits.get(k).website
                    ));
                }
            }
        }
        return sequences;
    }

    // Helper class to store visit data
    private static class Visit {
        int timestamp;
        String website;
        Visit(int timestamp, String website) {
            this.timestamp = timestamp;
            this.website = website;
        }
    }
}
```

---

### **Step-by-Step Explanation**

#### **1. Group Visits by User**
- **Goal:** Organize raw data by user for easier processing.
- **Method:**
  - Use a `HashMap<String, List<Visit>>` where the key is the username.
  - For each record, add a `Visit` (timestamp, website) to the user's list.

#### **2. Generate and Count 3-Sequences**
- **For each user:**
  - **Skip** users with fewer than 3 visits.
  - **Sort** visits by timestamp to ensure chronological order.
  - **Generate all unique 3-sequences** using nested loops (i < j < k).
  - **Count** each sequence globally using another `HashMap`.

#### **3. Determine the Result**
- **Find the sequence with the highest count.**
- **Handle ties:** If multiple sequences have the same count, pick the lexicographically smallest one (using `compareTo`).

---

### **Optimizations**
1. **Pre-sorting Visits:** Ensures sequences are generated in chronological order.
2. **HashSet for Sequences:** Avoids counting duplicate sequences for the same user.
3. **Early Termination:** Skips users with fewer than 3 visits immediately.

---

### **Complexity Analysis**
- **Time:**
  - Grouping: `O(N)` (N = number of records).
  - Sorting per user: `O(U * V log V)` (U = users, V = visits per user).
  - Sequence generation: `O(U * V^3)` in the worst case (but optimized with `HashSet`).
- **Space:**
  - `O(U * V)` for storing user visits.
  - `O(S)` for sequence counts (S = total unique sequences).

---

### **Example Walkthrough**
**Input:**
```java
username = ["joe","joe","joe","james","james","james","james","mary","mary","mary"],
timestamp = [1,2,3,4,5,6,7,8,9,10],
website = ["home","about","career","home","cart","maps","home","home","about","career"]
```

**Execution:**
1. **User "joe":** Visits `["home", "about", "career"]` â†’ Only one 3-sequence: `["home", "about", "career"]`.
2. **User "james":** Visits `["home", "cart", "maps", "home"]` â†’ Generates 4 sequences (e.g., `["home", "cart", "maps"]`).
3. **User "mary":** Visits `["home", "about", "career"]` â†’ Same as "joe".
4. **Result:** `["home", "about", "career"]` (appears twice, no ties).

**Output:** `["home", "about", "career"]`

---

### **Key Takeaways**
- **Grouping data by user** simplifies chronological processing.
- **Nested loops** efficiently generate sequences while avoiding duplicates.
- **Lexicographical comparison** handles frequency ties gracefully.

This solution efficiently handles the problem constraints while remaining readable and maintainable. ðŸš€



---------------------------------------------------------------------------------------------------------------

To do for interview
- [ ] Start with System design playlist from Gaurav sen
- [ ] 9 hard problems from leetcode as pdf
- [ ] Top 50 SDE
- [ ] Practice patterns of code with K5KC
- [ ] Practice proper patterns and sorting algorithms and other searching algorithms: merge sort, quick sort, kadanâ€™s algo, Kahnâ€™s algo
- [ ]


System design questions
- [ ] Ticket Master:
- [ ] Uber: https://www.youtube.com/watch?v=lsKU38RKQSo and https://www.youtube.com/watch?v=DGtalg5efCw , Reading: https://www.hellointerview.com/learn/system-design/problem-breakdowns/uber
- [ ] Instagram
- [ ] URL shirtner
- [ ] Notification service
- [ ] Youtube


Fiserv internal interview prep
- [ ] Spring boot
- [ ] Annotations in spring boot
- [ ] Spring webflux
- [ ] Async calls in spring boot: https://codefarm0.medium.com/scenario-based-java-multithreading-interview-questions-with-a-focus-on-completablefuture-e749bcbb7dbb
- [ ] Restful web services
- [ ]
- [ ] Multithreading in Java
- [ ] Java oops and basics
- [ ] Exception Handling
- [ ]
- [ ] SQL Interview questions: https://www.w3schools.com/sql/default.asp
- [ ] Micro-services and REST services concepts
- [ ] Overview of AWS components
- [ ] Check for all technologies in job description
- [ ]


Some useful resources:
OOPS:
	https://www.youtube.com/watch?v=5-9BhmP9Ufk
	https://www.geeksforgeeks.org/oops-interview-questions/
	https://medium.com/@akshatakanaje08/java-oops-interview-questions-and-answers-1e05c4df5ca5
	https://www.javaguides.net/2020/04/java-oops-quiz-coding-programs.html

Java: https://www.baeldung.com/java-interview-questions
	https://www.baeldung.com/java-8-interview-questions
	https://medium.com/@priyasrivastava18official/java-interview-questions-java-8-features-related-question-a8452082840b
	https://www.geeksforgeeks.org/java-8-interview-questions-and-answers/
Multithreading:
	https://codefarm0.medium.com/scenario-based-java-multithreading-interview-questions-with-a-focus-on-completablefuture-e749bcbb7dbb
	https://www.geeksforgeeks.org/java-multithreading-interview-questions-and-answers/

Springboot:
	https://www.geeksforgeeks.org/spring-boot-interview-questions-and-answers/
	https://medium.com/@sharmapraveen91/30-advanced-spring-boot-interview-questions-for-experienced-professionals-3574173472c1
	https://medium.com/@brijesh.sriv.misc/spring-reactive-interview-questions-fcab738063c9

JPA: https://www.baeldung.com/learn-jpa-hibernate

SQL:
	https://www.w3schools.com/sql/default.asp

To retrieve all repeated values from a table in SQL, use a SELECT statement with a GROUP BY clause and a HAVING clause.
SELECT name
FROM users
GROUP BY name
HAVING COUNT(*) > 1;


To retrieve all unique values from a table in SQL, you can use the SELECT DISTINCT statement
SELECT DISTINCT City
FROM Customers;

SELECT * FROM Customers
WHERE NOT Country ='Spain';

SELECT * FROM Customers
WHERE CustomerName NOT LIKE 'A%';



â€¢ Currently leading the development of the backend component of applications leveraging the Spring 3 framework within a Microservice architecture. Additionally, employing Java 17 features to drive innovative and efficient application development.
â€¢ Engaged in creating and extracting data from diverse databases, including Oracle, Azure, and Tandem systems, ensuring seamless data management and accessibility for organizational needs.
â€¢ Contributed to developing an encryption/decryption utility, enabling robust authentication and authorization mechanisms.
â€¢ Conducted comprehensive code reviews and executed unit tests utilizing the JUnit framework to ensure the robustness and quality of the application.
â€¢ Collaborated with product and business analysts to implement Swagger to generate interactive API documentation, enabling users to seamlessly test API calls directly from their web browsers.
â€¢ Developed APIs and REST API Proxy policy resources to serve as gateways for clients utilizing APIGEE Edge, ensuring secure and efficient communication and integration with external systems
â€¢ Proficient in CI/CD methodologies, including Azure Pipelines, and adept at managing Kubernetes environments such as OpenShift. Skilled in pod and route creation processes for seamless deployment of new microservices.
â€¢ Contributed to production support and maintenance efforts, resolving security vulnerabilities identified in SonarQube, Fortify, and Sona type across the project. Demonstrated proficiency in swiftly addressing security concerns to uphold the integrity and resilience of the system.
â€¢ Established and implemented GIT controls to track and manage various project versions effectively, ensuring streamlined development processes and version control. Currently engaged in research and exploration of GIT Copilot capabilities to enhance collaborative coding practices and efficiency within the development team.